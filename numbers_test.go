package numbers

import (
	"errors"
	"reflect"
	"testing"
)

// TestFactorsList unit test FactorsList function.
func TestFactorsList(t *testing.T) {
	testCases := []struct {
		input    int
		expected []int
		err      error
	}{
		{2, []int{2}, nil},
		{15, []int{3, 5}, nil},
		{26, []int{2, 13}, nil},
		{37, []int{37}, nil},
		{42, []int{2, 3, 7}, nil},
		{-1, []int(nil), errors.New("no prime factors for numbers below two. received '-1'")},
	}
	for _, test := range testCases {
		observed, err := FactorsList(test.input)
		if err != nil {
			if test.err.Error() != err.Error() {
				t.Error(err)
			}
		}
		if !reflect.DeepEqual(observed, test.expected) {
			t.Errorf("for input '%d', expected '%v', got '%v'",
				test.input, test.expected, observed)
		}
	}
}

// BenchmarkFactorList benchmark FactorsList function.
func BenchmarkFactorList(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_, err := FactorsList(1000)
		if err != nil {
			b.Error(err)
		}
	}
}

// TestIsPrime unit test IsPrime function.
func TestIsPrime(t *testing.T) {
	testCases := []struct {
		input    int
		expected bool
	}{
		{-5, false},
		{0, false},
		{2, true},
		{6, false},
		{13, true},
	}
	for _, test := range testCases {
		observed := IsPrime(test.input)
		if observed != test.expected {
			t.Errorf("for input '%d', expected '%t', got '%t'",
				test.input, test.expected, observed)
		}
	}
}

// BenchmarkIsPrime benchmark IsPrime function.
func BenchmarkIsPrime(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_ = IsPrime(1728459)
	}
}

// TestFibonacciGen unit test FibonacciGen function.
func TestFibonacciGen(t *testing.T) {
	testCases := []struct {
		input, expected int
	}{
		{1, 0},
		{2, 1},
		{3, 1},
		{4, 2},
		{5, 3},
		{8, 13},
		{10, 34},
		{12, 89},
	}
	for _, test := range testCases {
		var observed int
		c := FibonacciGen()
		for n := 0; n < test.input; n++ {
			observed = <-c
		}
		if observed != test.expected {
			t.Errorf("for input '%d', expected '%d', got '%d'", test.input, test.expected, observed)
		}
	}
}

// BenchmarkFibonacciGen benchmark FibonacciGen function.
func BenchmarkFibonacciGen(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		c := FibonacciGen()
		for n := 0; n < 10000; n++ {
			_ = <-c
		}
	}
}

// TestNthFibonacci unit test NthFibonacci function.
func TestNthFibonacci(t *testing.T) {
	var testCases = []struct {
		input, expected int
	}{
		{1, 1},
		{5, 5},
		{7, 13},
		{10, 55},
		{19, 4181},
	}
	for _, test := range testCases {
		observed := NthFibonacci(test.input)
		if observed != test.expected {
			t.Errorf("for input '%d', expected '%d', got '%d'",
				test.input, test.expected, observed)
		}
	}
}

// BenchmarkNthFibonacci benchmark NthFibonacci function.
func BenchmarkNthFibonacci(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = NthFibonacci(10000)
	}
}

// TestEvenNumbers unit test EvenNumbers function.
func TestEvenNumbers(t *testing.T) {
	testCases := []struct {
		inputA, inputB int
		expected       []int
		err            error
	}{
		{1, 1, []int(nil), nil},
		{1, 3, []int{2}, nil},
		{4, 8, []int{4, 6, 8}, nil},
		{-4, 8, []int{-4, -2, 0, 2, 4, 6, 8}, nil},
		{-1, -2, []int(nil), errors.New("a must be greater than b. received a '-1' and b '-2'")},
	}
	for _, test := range testCases {
		observed, err := EvenNumbers(test.inputA, test.inputB)
		if err != nil {
			if err.Error() != test.err.Error() {
				t.Error(err)
			}
		}
		if !reflect.DeepEqual(observed, test.expected) {
			t.Errorf("for a '%d' and b '%d', expected '%v', got '%v'",
				test.inputA, test.inputB, test.expected, observed)
		}
	}
}

// BenchmarkEvenNumbers benchmark EvenNumbers function.
func BenchmarkEvenNumbers(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_, err := EvenNumbers(1, 100000)
		if err != nil {
			b.Error(err)
		}
	}
}

// TestOddNumbers unit test OddNumbers function.
func TestOddNumbers(t *testing.T) {
	testCases := []struct {
		inputA, inputB int
		expected       []int
		err            error
	}{
		{1, 1, []int{1}, nil},
		{1, 3, []int{1, 3}, nil},
		{4, 8, []int{5, 7}, nil},
		{-4, 8, []int{-3, -1, 1, 3, 5, 7}, nil},
		{-1, -2, []int(nil), errors.New("a must be greater than b. received a '-1' and b '-2'")},
	}
	for _, test := range testCases {
		observed, err := OddNumbers(test.inputA, test.inputB)
		if err != nil {
			if err.Error() != test.err.Error() {
				t.Error(err)
			}
		}
		if !reflect.DeepEqual(observed, test.expected) {
			t.Errorf("for a '%d' and b '%d', expected '%v', got '%v'",
				test.inputA, test.inputB, test.expected, observed)
		}
	}
}

// BenchmarkOddNumbers benchmark OddNumbers function.
func BenchmarkOddNumbers(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_, err := OddNumbers(1, 100000)
		if err != nil {
			b.Error(err)
		}
	}
}

// TestNthEven unit test NthEven function.
func TestNthEven(t *testing.T) {
	testCases := []struct {
		input, expected int
		err             error
	}{
		{-1, 0, errors.New("input must be a positive number. received '-1'")},
		{-2, 0, errors.New("input must be a positive number. received '-2'")},
		{1, 0, nil},
		{2, 2, nil},
		{10, 18, nil},
	}
	for _, test := range testCases {
		observed, err := NthEven(test.input)
		if err != nil {
			if err.Error() != test.err.Error() {
				t.Errorf("for input '%d', expected '%s', got '%s'",
					test.input, test.err.Error(), err.Error())
			}
		}
		if !reflect.DeepEqual(observed, test.expected) {
			t.Errorf("for input '%d', expected '%v', got '%v'",
				test.input, test.expected, observed)
		}
	}
}

// BenchmarkNthEven benchmark NthEven function.
func BenchmarkNthEven(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_, err := NthEven(100000)
		if err != nil {
			b.Error(err)
		}
	}
}

// TestNthOdd unit test NthOdd function.
func TestNthOdd(t *testing.T) {
	testCases := []struct {
		input, expected int
		err             error
	}{
		{-1, 0, errors.New("input must be a positive number. received '-1'")},
		{-2, 0, errors.New("input must be a positive number. received '-2'")},
		{1, 1, nil},
		{2, 3, nil},
		{10, 19, nil},
	}
	for _, test := range testCases {
		observed, err := NthOdd(test.input)
		if err != nil {
			if err.Error() != test.err.Error() {
				t.Errorf("for input '%d', expected '%s', got '%s'",
					test.input, test.err.Error(), err.Error())
			}
		}
		if !reflect.DeepEqual(observed, test.expected) {
			t.Errorf("for input '%d', expected '%v', got '%v'",
				test.input, test.expected, observed)
		}
	}
}

// BenchmarkNthOdd benchmark NthOdd function.
func BenchmarkNthOdd(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_, err := NthOdd(100000)
		if err != nil {
			b.Error(err)
		}
	}
}

// TestSliceByParity unit test SliceByParity  function.
func TestSliceByParity(t *testing.T) {
	testCases := []struct {
		inputA, inputB            int
		expectedEven, expectedOdd []int
	}{
		{1, 1, []int(nil), []int{1}},
		{1, 3, []int{2}, []int{1, 3}},
		{4, 8, []int{4, 6, 8}, []int{5, 7}},
		{-4, 8, []int{-4, -2, 0, 2, 4, 6, 8}, []int{-3, -1, 1, 3, 5, 7}},
	}
	for _, test := range testCases {
		observedEven, observedOdd, err := SliceByParity(test.inputA, test.inputB)
		if err != nil {
			t.Error(err)
		}
		if !reflect.DeepEqual(observedEven, test.expectedEven) {
			t.Errorf("for a '%d' and b '%d', expected even '%v', got '%v'",
				test.inputA, test.inputB, test.expectedEven, observedEven)
		}
		if !reflect.DeepEqual(observedOdd, test.expectedOdd) {
			t.Errorf("for a '%d' and b '%d', expected odd '%v', got '%v'",
				test.inputA, test.inputB, test.expectedOdd, observedOdd)
		}
	}
}

// BenchmarkSliceByParity benchmark SliceByParity function.
func BenchmarkSliceByParity(b *testing.B) {
	for i := 0; i <= b.N; i++ {
		_, _, err := SliceByParity(1, 100000)
		if err != nil {
			b.Error(err)
		}
	}
}
